<!DOCTYPE html><html lang="en"><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description" content=""><link rel="stylesheet" type="text/css" href="//fonts.loli.net/css?family=Source+Code+Pro"><link rel="stylesheet" type="text/css" href="/css/style.css?v=2.0.4"><link rel="stylesheet" type="text/css" href="/css/highlight.css?v=2.0.4"><link rel="Shortcut Icon" href="/favicon.ico"><link rel="bookmark" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"><title>1.复杂度分析 | Hexo</title><meta name="generator" content="Hexo 4.0.0"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">1.复杂度分析</h1><a id="logo" href="/.">Hexo</a><p class="description"></p></div><div id="nav-menu"><a href="/." class="current"><i class="fa fa-home"> Home</i></a><a href="/archives/"><i class="fa fa-archive"> Archive</i></a><a href="/about/"><i class="fa fa-user"> About</i></a></div><div id="search-form"><div id="result-mask" class="hide"></div><label><input id="search-key" type="text" autocomplete="off" placeholder="search"></label><div id="result-wrap" class="hide"><div id="search-result"></div></div><div class="hide"><template id="search-tpl"><div class="item"><a href="/{path}" title="{title}"><div class="title">{title}</div><div class="time">{date}</div><div class="tags">{tags}</div></a></div></template></div></div></div><div id="layout" class="layout-g"><div class="layout-l"><div class="content_container"><div class="post"><h1 class="post-title">1.复杂度分析</h1><div class="post-meta"><a href="/2019/11/30/1.ComplexityAnalysis/#comments" class="comment-count"></a><p><span class="date">Nov 30, 2019</span><span><i id="busuanzi_container_page_pv"><i id="busuanzi_value_page_pv"></i><i>Hits</i></i></span></p></div><div class="post-content"><p>计算机讲求的是运行的更快，更省内存空间，也就是对执行效率（时间）和资源消耗（空间）的要求。故在写算法时，要进行时间复杂度和空间复杂度分析，才能评断算法的好坏。</p>
<h2 id="为什么要复杂度分析"><a href="#为什么要复杂度分析" class="headerlink" title="为什么要复杂度分析"></a>为什么要复杂度分析</h2><p>直接拿算法进行测试，得到执行时间和占用空间大小，这叫<em>事后统计法</em></p>
<ol>
<li>测试结果受测试环境影响</li>
<li>测试结果受数据规模影响</li>
</ol>
<p>我们需要用一个不用具体数据进行测试，就能估计出算法的执行时间和占用空间的方法， 即进行时间、空间复杂度分析。</p>
<h2 id="复杂度分析的方法（大O复杂度表示法）"><a href="#复杂度分析的方法（大O复杂度表示法）" class="headerlink" title="复杂度分析的方法（大O复杂度表示法）"></a>复杂度分析的方法（大O复杂度表示法）</h2><h3 id="时间复杂度分析"><a href="#时间复杂度分析" class="headerlink" title="时间复杂度分析"></a>时间复杂度分析</h3><blockquote>
<p>时间复杂度（Time complexity）：代码执行时间随数据规模增长的变化趋势</p>
</blockquote>
<ol>
<li><p>关注循环执行次数最多的一段代码</p>
</li>
<li><p>加法法则： 总时间复杂度 = 量级最大的那段代码的复杂度</p>
<blockquote>
<p>给定已知的循环次数，即使是10000次，十万次，也是常量级时复</p>
</blockquote>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">int cal(int n) &#123; </span><br><span class="line">    int sum_1 = 0; </span><br><span class="line">    int p = 1; </span><br><span class="line">    for (; p &lt; 1000; ++p) &#123; </span><br><span class="line">        sum_1 = sum_1 + p; </span><br><span class="line">    &#125; </span><br><span class="line">    </span><br><span class="line">    int sum_2 = 0; </span><br><span class="line">    int q = 1; </span><br><span class="line">    for (; q &lt; n; ++q) &#123; </span><br><span class="line">        sum_2 = sum_2 + q; </span><br><span class="line">    &#125; </span><br><span class="line">    </span><br><span class="line">    int sum_3 = 0; </span><br><span class="line">    int i = 1; </span><br><span class="line">    int j = 1; </span><br><span class="line">    for (; i &lt;= n; ++i) &#123; </span><br><span class="line">        j = 1; </span><br><span class="line">        for (; j &lt;= n; ++j) &#123; </span><br><span class="line">            sum_3 = sum_3 + i * j; </span><br><span class="line">        &#125; </span><br><span class="line">    &#125; </span><br><span class="line">    </span><br><span class="line">    return sum_1 + sum_2 + sum_3; &#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>第一段代码循环大概1000次，也是常量级，时复O（1）; 第二段循环n次，时复O（n）； 第三段循环n^2次，时复O（n^2）。 所以整个函数的时复为O（n^2）</p>
</blockquote>
</li>
<li><p>乘法法则：嵌套代码复杂度 = 嵌套代码内外循环复杂度的乘积</p>
</li>
</ol>
<h3 id="常见时间复杂度实例分析"><a href="#常见时间复杂度实例分析" class="headerlink" title="常见时间复杂度实例分析"></a>常见时间复杂度实例分析</h3><p><img src="/2019/11/30/1/ordinaryComplexity.jpg" alt="Alt"></p>
<ol>
<li>将对数阶O（logn）循环n次， 就是O（nlogn）</li>
<li>O（m + n）， O（m * n） 数据规模m、n均未知</li>
</ol>
<h3 id="空间复杂度分析"><a href="#空间复杂度分析" class="headerlink" title="空间复杂度分析"></a>空间复杂度分析</h3><p>空间复杂度（Space complexity）：算法的存储空间随数据规模增长的变化趋势<br>常见空间复杂度： O（1） O（n） O（n^2）</p>
<h2 id="最好最坏时间复杂度"><a href="#最好最坏时间复杂度" class="headerlink" title="最好最坏时间复杂度"></a>最好最坏时间复杂度</h2><h2 id="平均时间复杂度"><a href="#平均时间复杂度" class="headerlink" title="平均时间复杂度"></a>平均时间复杂度</h2><p>find（）：假设查找x在数组中的位置，存在0 ~ n-1位置上和不在数组中，共n+1中情况，那么平均情况的复杂度=（1+2+…+n+n）/（n+1）= n（n+3）/ 2(n+1)， 去除系数、低阶、常量，时复为O（n）</p>
<p>以上计算方法是错误的，没有考虑每种情况的概率。x是否存在于数组的概率各占1/2， x存在于0 ~ n-1位置上的概率各为1/2n, 所以（1+2+…+n）* 1/2n + n * 1/2 = 3n + 1 / 4, 故平均时复为O（n）。加入概率的叫做加权平均值（期望值），故称为加权平均时间复杂度,简称平均时间复杂度。</p>
<h2 id="均摊时间复杂度"><a href="#均摊时间复杂度" class="headerlink" title="均摊时间复杂度"></a>均摊时间复杂度</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">// array表示一个长度为n的数组</span><br><span class="line">// 代码中的array.length就等于n</span><br><span class="line">int[] array = new int[n];</span><br><span class="line">int count = 0;</span><br><span class="line"></span><br><span class="line">void insert(int val) &#123;</span><br><span class="line">   if (count == array.length) &#123;</span><br><span class="line">      int sum = 0;</span><br><span class="line">      for (int i = 0; i &lt; array.length; ++i) &#123;</span><br><span class="line">         sum = sum + array[i];</span><br><span class="line">      &#125;</span><br><span class="line">      array[0] = sum;</span><br><span class="line">      count = 1;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   array[count] = val;</span><br><span class="line">   ++count;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>这段代码的功能是：数组没满时，直接插入元素；数组已满时，计算所有元素的和，清空数组，并将和存放在array[0],继续插入元素。</p>
<ol>
<li><p>最好时复：数组没满，直接插入，O（1）</p>
</li>
<li><p>最坏时复：数组已满，先求和再插入语， O（n）</p>
</li>
<li><p>平均时复：根据插入的位置不同，分为0 ~ n-1， 和数组已满插入元素，共n+1种情况，每种情况发生的概率是1 / n+1。 而前n种的时复是O（1）， 最后一种的时复是O（n）， 所以1 * 1/n+1 + … + 1 * 1/n+1 + n * 1/n+1 = 2n / n+1, 故平均时复为O（1）</p>
</li>
<li><p>什么时候使用平均时复或是均摊时复？</p>
<p>find（）和insert（）的对比：find（）最好情况为O（1），insert（）在大部分情况下为O（1），极端情况才为O（n）。 inset（）的时复出现是有规律的， 一次O（n）插入操作后会有n-1次的O（1）插入操作，针对这种特殊场景，不再使用较复杂的平均时复分析法， 而是采用摊还分析，求均摊时间复杂度。</p>
</li>
<li><p>均摊时复：将耗时最多的一次O（n）操作，均摊到n-1次耗时少的O（1）操作，那么每次操作的时复都是O（1）。故均摊时复为O（1）。</p>
</li>
</ol>
</blockquote>
<h3 id="什么时候用摊还分析法来估计算法的均摊时间复杂度？"><a href="#什么时候用摊还分析法来估计算法的均摊时间复杂度？" class="headerlink" title="什么时候用摊还分析法来估计算法的均摊时间复杂度？"></a>什么时候用摊还分析法来估计算法的均摊时间复杂度？</h3><p>当在特殊场景下，算法操作的时复有规律地分布着，看看是否能够把较高时间复杂度的操作均摊到较低时复的操作上。一般情况，均摊时复等于最好时复。 均摊时复是一种特殊的平均时复。</p>
<h2 id="思考题"><a href="#思考题" class="headerlink" title="思考题"></a>思考题</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">// 全局变量，大小为10的数组array，长度len，下标i。</span><br><span class="line">int array[] = new int[10]; </span><br><span class="line">int len = 10;</span><br><span class="line">int i = 0;</span><br><span class="line"></span><br><span class="line">// 往数组中添加一个元素</span><br><span class="line">void add(int element) &#123;</span><br><span class="line">   if (i &gt;= len) &#123; // 数组空间不够了</span><br><span class="line">     // 重新申请一个2倍大小的数组空间</span><br><span class="line">     int new_array[] = new int[len*2];</span><br><span class="line">     // 把原来array数组中的数据依次copy到new_array</span><br><span class="line">     for (int j = 0; j &lt; len; ++j) &#123;</span><br><span class="line">       new_array[j] = array[j];</span><br><span class="line">     &#125;</span><br><span class="line">     // new_array复制给array，array现在大小就是2倍len了</span><br><span class="line">     array = new_array;</span><br><span class="line">     len = 2 * len;</span><br><span class="line">   &#125;</span><br><span class="line">   // 将element放到下标为i的位置，下标i加一</span><br><span class="line">   array[i] = element;</span><br><span class="line">   ++i;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>最好时复：数组未满，直接添加，O（1）</p>
<p>最坏时复：数组已满，扩容搬移数据后再添加，O（n）</p>
<p>摊还时复： 将搬移数据的操作均摊到前n-1次直接添加的操作，时复等于直接添加的时复O（1）</p>
</blockquote>
</div><div class="post-copyright"><blockquote><p>Original author: Skylar Ran</p><p>Original link: <a href="http://SkylarRan.com/2019/11/30/1.ComplexityAnalysis/">http://SkylarRan.com/2019/11/30/1.ComplexityAnalysis/</a></p><p>Copyright Notice: Please indicate the source of the reprint (must retain the author's signature and link)</p></blockquote></div><div class="tags"><a href="/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E4%B9%8B%E7%BE%8E/">数据结构与算法之美</a></div><div class="post-share"><div class="social-share"><span>Share:</span></div></div><div class="post-nav"><a href="/2019/11/12/%E5%8F%99%E8%BF%B0%E6%99%9A%E4%B8%8A%E7%9A%84%E6%B4%BB%E5%8A%A8/" class="next">叙述晚上的活动</a></div><div id="comments"></div></div></div></div><div class="layout-r"><div id="sidebar"><div class="search-pla"></div><div id="toc" class="widget"><div class="widget-title"><i class="fa fa-fei">Contents</i></div><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#为什么要复杂度分析"><span class="toc-text">为什么要复杂度分析</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#复杂度分析的方法（大O复杂度表示法）"><span class="toc-text">复杂度分析的方法（大O复杂度表示法）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#时间复杂度分析"><span class="toc-text">时间复杂度分析</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#常见时间复杂度实例分析"><span class="toc-text">常见时间复杂度实例分析</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#空间复杂度分析"><span class="toc-text">空间复杂度分析</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#最好最坏时间复杂度"><span class="toc-text">最好最坏时间复杂度</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#平均时间复杂度"><span class="toc-text">平均时间复杂度</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#均摊时间复杂度"><span class="toc-text">均摊时间复杂度</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#什么时候用摊还分析法来估计算法的均摊时间复杂度？"><span class="toc-text">什么时候用摊还分析法来估计算法的均摊时间复杂度？</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#思考题"><span class="toc-text">思考题</span></a></li></ol></div><div class="widget"><div class="widget-title"><i class="fa fa-xie"> Recent</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2019/11/30/1.ComplexityAnalysis/">1.复杂度分析</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/11/12/%E5%8F%99%E8%BF%B0%E6%99%9A%E4%B8%8A%E7%9A%84%E6%B4%BB%E5%8A%A8/">叙述晚上的活动</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/11/12/hello-world/">Hello World</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-biao"> Tags</i></div><div class="tagcloud"><a href="/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E4%B9%8B%E7%BE%8E/" style="font-size: 15px;">数据结构与算法之美</a> <a href="/tags/test/" style="font-size: 15px;">test</a></div></div><div class="widget"><div class="widget-title"><i class="fa fa-archive"> Archive</i></div><ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/">2019</a><span class="archive-list-count">3</span></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-you"> Blogroll</i></div><ul></ul><a href="http://www.example1.com/" title="site-name1" target="_blank">site-name1</a><ul></ul><a href="http://www.example2.com/" title="site-name2" target="_blank">site-name2</a><ul></ul><a href="http://www.example3.com/" title="site-name3" target="_blank">site-name3</a></div></div></div></div><a id="totop" href="#top"></a><div id="footer"><div class="footer-info"><p><a href="/baidusitemap.xml">Site Map</a> |  <a href="/atom.xml">Subscribe to this site</a> |  <a href="/about/">Contact the blogger</a></p><p>本站总访问量：<i id="busuanzi_container_site_pv"><i id="busuanzi_value_site_pv"></i></i>次，本站总访客数:<i id="busuanzi_container_site_uv"><i id="busuanzi_value_site_uv"></i></i>人</p><p><span> Copyright &copy;<a href="/." rel="nofollow">Skylar Ran.</a></span><span> Theme by<a rel="nofollow" target="_blank" href="https://github.com/chaooo/hexo-theme-BlueLake"> BlueLake.</a></span><span> Count by<a href="http://busuanzi.ibruce.info/" target="_blank" rel="noopener"> busuanzi.</a></span><span> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a></span></p></div></div></div><script src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" async></script><script type="text/javascript" src="/js/search.json.js?v=2.0.4"></script><script type="text/javascript" src="/js/toctotop.js?v=2.0.4" async></script><link rel="stylesheet" type="text/css" href="/share/css/share.css"><script type="text/javascript" src="/share/js/social-share.js" charset="utf-8"></script><script type="text/javascript" src="/share/js/qrcode.js" charset="utf-8"></script></body></html>