[{"title":"1.复杂度分析","url":"/2019/11/30/1.ComplexityAnalysis/","content":"\n计算机讲求的是运行的更快，更省内存空间，也就是对执行效率（时间）和资源消耗（空间）的要求。故在写算法时，要进行时间复杂度和空间复杂度分析，才能评断算法的好坏。\n\n## 为什么要复杂度分析\n\n直接拿算法进行测试，得到执行时间和占用空间大小，这叫*事后统计法*\n1. 测试结果受测试环境影响\n2. 测试结果受数据规模影响\n \n我们需要用一个不用具体数据进行测试，就能估计出算法的执行时间和占用空间的方法， 即进行时间、空间复杂度分析。\n\n## 复杂度分析的方法（大O复杂度表示法）\n### 时间复杂度分析\n> 时间复杂度（Time complexity）：代码执行时间随数据规模增长的变化趋势\n\n1. 关注循环执行次数最多的一段代码\n2. 加法法则： 总时间复杂度 = 量级最大的那段代码的复杂度\n    > 给定已知的循环次数，即使是10000次，十万次，也是常量级时复\n\n    ```\n    int cal(int n) { \n        int sum_1 = 0; \n        int p = 1; \n        for (; p < 1000; ++p) { \n            sum_1 = sum_1 + p; \n        } \n        \n        int sum_2 = 0; \n        int q = 1; \n        for (; q < n; ++q) { \n            sum_2 = sum_2 + q; \n        } \n        \n        int sum_3 = 0; \n        int i = 1; \n        int j = 1; \n        for (; i <= n; ++i) { \n            j = 1; \n            for (; j <= n; ++j) { \n                sum_3 = sum_3 + i * j; \n            } \n        } \n        \n        return sum_1 + sum_2 + sum_3; }\n    ```\n\n    > 第一段代码循环大概1000次，也是常量级，时复O（1）; 第二段循环n次，时复O（n）； 第三段循环n^2次，时复O（n^2）。 所以整个函数的时复为O（n^2）\n\n3. 乘法法则：嵌套代码复杂度 = 嵌套代码内外循环复杂度的乘积\n\n### 常见时间复杂度实例分析\n![Alt](img/ordinaryComplexity.jpg)\n1. 将对数阶O（logn）循环n次， 就是O（nlogn）\n2. O（m + n）， O（m * n） 数据规模m、n均未知\n\n### 空间复杂度分析\n空间复杂度（Space complexity）：算法的存储空间随数据规模增长的变化趋势\n常见空间复杂度： O（1） O（n） O（n^2）\n\n## 最好最坏时间复杂度\n## 平均时间复杂度\n\nfind（）：假设查找x在数组中的位置，存在0 ~ n-1位置上和不在数组中，共n+1中情况，那么平均情况的复杂度=（1+2+...+n+n）/（n+1）= n（n+3）/ 2(n+1)， 去除系数、低阶、常量，时复为O（n）\n\n以上计算方法是错误的，没有考虑每种情况的概率。x是否存在于数组的概率各占1/2， x存在于0 ~ n-1位置上的概率各为1/2n, 所以（1+2+...+n）* 1/2n + n * 1/2 = 3n + 1 / 4, 故平均时复为O（n）。加入概率的叫做加权平均值（期望值），故称为加权平均时间复杂度,简称平均时间复杂度。\n\n## 均摊时间复杂度\n\n```\n // array表示一个长度为n的数组\n // 代码中的array.length就等于n\n int[] array = new int[n];\n int count = 0;\n \n void insert(int val) {\n    if (count == array.length) {\n       int sum = 0;\n       for (int i = 0; i < array.length; ++i) {\n          sum = sum + array[i];\n       }\n       array[0] = sum;\n       count = 1;\n    }\n\n    array[count] = val;\n    ++count;\n }\n```\n> 这段代码的功能是：数组没满时，直接插入元素；数组已满时，计算所有元素的和，清空数组，并将和存放在array[0],继续插入元素。\n> 1. 最好时复：数组没满，直接插入，O（1）\n> 2. 最坏时复：数组已满，先求和再插入语， O（n）\n> 3. 平均时复：根据插入的位置不同，分为0 ~ n-1， 和数组已满插入元素，共n+1种情况，每种情况发生的概率是1 / n+1。 而前n种的时复是O（1）， 最后一种的时复是O（n）， 所以1 * 1/n+1 + ... + 1 * 1/n+1 + n * 1/n+1 = 2n / n+1, 故平均时复为O（1）\n> 4. 什么时候使用平均时复或是均摊时复？\n>      \n>    find（）和insert（）的对比：find（）最好情况为O（1），insert（）在大部分情况下为O（1），极端情况才为O（n）。 inset（）的时复出现是有规律的， 一次O（n）插入操作后会有n-1次的O（1）插入操作，针对这种特殊场景，不再使用较复杂的平均时复分析法， 而是采用摊还分析，求均摊时间复杂度。\n> 5. 均摊时复：将耗时最多的一次O（n）操作，均摊到n-1次耗时少的O（1）操作，那么每次操作的时复都是O（1）。故均摊时复为O（1）。\n \n### 什么时候用摊还分析法来估计算法的均摊时间复杂度？\n\n当在特殊场景下，算法操作的时复有规律地分布着，看看是否能够把较高时间复杂度的操作均摊到较低时复的操作上。一般情况，均摊时复等于最好时复。 均摊时复是一种特殊的平均时复。\n\n## 思考题\n\n```\n\n// 全局变量，大小为10的数组array，长度len，下标i。\nint array[] = new int[10]; \nint len = 10;\nint i = 0;\n\n// 往数组中添加一个元素\nvoid add(int element) {\n   if (i >= len) { // 数组空间不够了\n     // 重新申请一个2倍大小的数组空间\n     int new_array[] = new int[len*2];\n     // 把原来array数组中的数据依次copy到new_array\n     for (int j = 0; j < len; ++j) {\n       new_array[j] = array[j];\n     }\n     // new_array复制给array，array现在大小就是2倍len了\n     array = new_array;\n     len = 2 * len;\n   }\n   // 将element放到下标为i的位置，下标i加一\n   array[i] = element;\n   ++i;\n}\n```\n> 最好时复：数组未满，直接添加，O（1）\n> \n> 最坏时复：数组已满，扩容搬移数据后再添加，O（n）\n> \n> 摊还时复： 将搬移数据的操作均摊到前n-1次直接添加的操作，时复等于直接添加的时复O（1）\n> ","tags":["数据结构与算法之美"]},{"title":"Hello World","url":"/2019/11/12/hello-world/","content":"Welcome to [Hexo](https://hexo.io/)! This is your very first post. Check [documentation](https://hexo.io/docs/) for more info. If you get any problems when using Hexo, you can find the answer in [troubleshooting](https://hexo.io/docs/troubleshooting.html) or you can ask me on [GitHub](https://github.com/hexojs/hexo/issues).\n\n## Quick Start\n\n### Create a new post\n\n``` bash\n$ hexo new \"My New Post\"\n```\n\nMore info: [Writing](https://hexo.io/docs/writing.html)\n\n### Run server\n\n``` bash\n$ hexo server\n```\n\nMore info: [Server](https://hexo.io/docs/server.html)\n\n### Generate static files\n\n``` bash\n$ hexo generate\n```\n\nMore info: [Generating](https://hexo.io/docs/generating.html)\n\n### Deploy to remote sites\n\n``` bash\n$ hexo deploy\n```\n\nMore info: [Deployment](https://hexo.io/docs/one-command-deployment.html)\n"}]