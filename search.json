[{"title":"ArrayList源码分析","url":"/2020/04/27/ArrayList源码分析/","content":"# ArrayList\n\n## 1. 概览\n\nArrayList基于数组实现，支持快速随机访问。RandomAccess接口标示着该类支持随机访问。\n<!-- more -->\n\n```java\npublic class ArrayList<E>\nextends AbstractList<E>\nimplements List<E>, RandomAccess, Cloneable, Serializable\n```\n\n容量大小默认为10。\n\n```java\nprivate static final int DEFAULT_CAPACITY = 10;\n```\n\n## 2. 扩容\n\n添加元素时使用ensureCapacityInternal（）来保证容量足够，如果不够，需要grow（）来进行扩容，`oldCapacity + (oldCapacity >> 1)`，也就是旧容量的1.5倍。\n\n扩容操作要调用`Arrays.copyOf()`  把原数组元素复制到新数组中，这个操作的代价很高，所以最好在创建ArrayList对象时就指定大概的容量大小，减少扩容操作的次数。\n\n```java\npublic boolean add(E e) {\n    ensureCapacityInternal(size + 1);  // Increments modCount!!\n    elementData[size++] = e;\n    return true;\n}\n\nprivate void ensureCapacityInternal(int minCapacity) {\n    ensureExplicitCapacity(calculateCapacity(elementData, minCapacity));\n}\n\nprivate static int calculateCapacity(Object[] elementData, int minCapacity) {\n    if (elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA) {\n        return Math.max(DEFAULT_CAPACITY, minCapacity);\n    }\n    return minCapacity;\n}\n\nprivate void ensureExplicitCapacity(int minCapacity) {\n    modCount++;\n\n    // overflow-conscious code\n    if (minCapacity - elementData.length > 0)\n        grow(minCapacity);\n}\n\nprivate void grow(int minCapacity) {\n    // overflow-conscious code\n    int oldCapacity = elementData.length;\n    int newCapacity = oldCapacity + (oldCapacity >> 1);\n    if (newCapacity - minCapacity < 0)\n        newCapacity = minCapacity;\n    if (newCapacity - MAX_ARRAY_SIZE > 0)\n        newCapacity = hugeCapacity(minCapacity);\n    // minCapacity is usually close to size, so this is a win:\n    elementData = Arrays.copyOf(elementData, newCapacity);\n}\n\n```\n\n## 3. 删除元素\n\n需要调用`System.arraycopy()` 将index + 1后面的元素都复制到index 上，时间复杂度为O（n），所以ArrayList删除元素的代价也是很高的。\n\n```java\npublic E remove(int index) {\n    rangeCheck(index);\n\n    modCount++;\n    E oldValue = elementData(index);\n\n    int numMoved = size - index - 1;\n    if (numMoved > 0)\n        System.arraycopy(elementData, index+1, elementData, index,\n                         numMoved);\n    elementData[--size] = null; // clear to let GC do its work\n\n    return oldValue;\n}\n```\n\n## 4. 序列化\n\n- 序列化：将对象写入到IO流中\n- 反序列化：从IO流中输出对象\n- 意义：序列化机制可以将Java对象转化成位字节序列，这些位字节序列可以保存在磁盘上，或者通过网络传输，恢复成原来的对象。序列化机制可以使对象脱离程序的运行而独立存在。\n- 应用场景：需要进行网络传输的对象或需要保存在磁盘上的对象都必须使可序列化的。 通常建议：程序创建的每个JavaBean类都实现Serializable接口。\n\nArrayList基于数组实现，具有动态扩容的特性，因此保存元素的数组不一定都会被使用，所以就没必要全部进行序列化。\n\n保存数组的elementData由transient修饰，表示数组被默认不会序列化。\n\n```java\ntransient Object[] elementData; // non-private to simplify nested class access\n```\n\nArrayList实现了writeObject()和 readObject()来控制只序列化有元素填充的那部分。\n\n```java\nprivate void writeObject(java.io.ObjectOutputStream s)\n    throws java.io.IOException{\n    // Write out element count, and any hidden stuff\n    int expectedModCount = modCount;\n    s.defaultWriteObject();\n\n    // Write out size as capacity for behavioural compatibility with clone()\n    s.writeInt(size);\n\n    // Write out all elements in the proper order.\n    for (int i=0; i<size; i++) {\n        s.writeObject(elementData[i]);\n    }\n\n    if (modCount != expectedModCount) {\n        throw new ConcurrentModificationException();\n    }\n}\n\nprivate void readObject(java.io.ObjectInputStream s)\n    throws java.io.IOException, ClassNotFoundException {\n    elementData = EMPTY_ELEMENTDATA;\n\n    // Read in size, and any hidden stuff\n    s.defaultReadObject();\n\n    // Read in capacity\n    s.readInt(); // ignored\n\n    if (size > 0) {\n        // be like clone(), allocate array based upon size not capacity\n        int capacity = calculateCapacity(elementData, size);\n        SharedSecrets.getJavaOISAccess().checkArray(s, Object[].class, capacity);\n        ensureCapacityInternal(size);\n\n        Object[] a = elementData;\n        // Read in all elements in the proper order.\n        for (int i=0; i<size; i++) {\n            a[i] = s.readObject();\n        }\n    }\n}\n\n```\n\n序列化时需要使用ObjectOutputStream的writeObject() 将对象转化为字节流并输出。**而 writeObject() 方法在传入的对象存在 writeObject() 的时候会去反射调用该对象的 writeObject() 来实现序列化。**\n\n反序列化使用ObjectInputStream的readObject() ,原理类似。\n\n```java\nArrayList list = new Arratlist();\nObjectOutputStream oos = new ObjectOutputStream(new FileOutputStream(file));\noos.writeObject(list); // 这段代码会通过反射让list调用它的list.writeObject()\n```\n\n## 5. Fail-Fast\n\n- “fail-fast”\n\n  - 也就是“快速失败”，它是Java集合的一种错误检测机制。某个线程在对集合进行迭代时，不允许其他线程对该集合进行结构上的修改。若迭代时出现结构性改变，会抛出ConcurrentModificationException异常。\n  - 迭代器的快速失败行为无法得到保证，它不能保证一定会出现该错误，因此，ConcurrentModificationException应该仅用于检测 bug。\n  - Java.util包中的所有集合类都是快速失败的，而java.util.concurrent包中的集合类都是安全失败的；\n    快速失败的迭代器抛出ConcurrentModificationException，而安全失败的迭代器从不抛出这个异常。\n\n- modCount\n\n  - ArrayList继承了抽象类AbstractList，同时也就拥有了AbstractList中的全局变量modCount，用来记录ArrayList发生结构性改变的次数。结构性改变指的是添加或者删除至少一个元素的所有操作，或者是调整内部数组的大小操作，在迭代过程中可能会造成错误的结果。仅仅只是设置元素的值不算结构发生变化。\n\n  - modCount交由迭代器（Iterator）和列表迭代器（ListIterator）使用，当进行next()、remove()、previous()、set()、add()等操作时，如果modCount的值意外改变，那么迭代器或者列表迭代器就会抛出ConcurrentModificationException异常。代码参考上一点序列化函数实现。\n\n## 总结\n\n- ArrayList基于数组实现，支持快速随机访问。\n- 数组容量大小默认为10，动态扩容的大小是原来的1.5倍。\n- 插入和删除操作涉及元素的移动，操作代价是极高的，故最好在创建时就指定大概的数组大小。\n- 数组默认不用序列化，ArrayList中实现了读写对象的方法，用来控制对已填充元素的那部分进行序列化。","tags":["Java容器"],"categories":["Java","Java容器"]},{"title":"Java容器","url":"/2020/04/27/概览/","content":"\n# 一、 概览\n\n容器分为Collection和Map两种， Collection是存储（单个）对象的集合，Map是存储键值对（两个对象）的映射表。\n<!-- more -->\n\n## Collection\n\n![collection](/collection.png)\n\n1. Set\n\n   - set 存放的元素不能重复\n\n   - TreeSet：基于红黑树实现，O（logN）\n   - HashSet：基于哈希表实现，支持快速查找，O（1），元素无序。 失去了元素的顺序信息，意味着使用 Iterator 遍历的结果是不确定的。\n   - LinkedHashSet：具有HashSet的查找效率，内部使用的是双向链表维护元素的插入顺序。\n\n2. List\n\n   - list 可以存放重复元素\n   - ArrayList：基于动态数组实现，支持随机访问\n   - Vector：和ArrayList类似，但它是线程安全的\n   - LinkedList：基于双向链表实现，只能按顺序访问，但插入和删除元素迅速。LinkedList还可用作栈、队列和双向队列。\n\n3. Queue\n\n   - queue “先进先出”\n   - LinkedList： 可用作队列和双向队列\n   - PriorityQueue：基于堆结构实现，用作优先队列\n\n\n## Map\n\n![map](/map.png)\n\n- HashMap：基于哈希表实现。\n- HashTable：和HashMap类似，它是线程安全的。但它是遗留类，不应该使用它，而是使用ConcurrentHasgMap来支持线程安全。ConcurrentHashMap的执行效率更高，因为它引用了分段锁。\n- LinkedHashMap：使用双向链表来维护元素的顺序，顺序是插入顺序或最近最少使用（LRU）顺序。\n- TreeMap：基于红黑树实现。\n\n# 二、容器中的设计模式\n\n## 迭代器模式\n\n![img](https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/image-20191208225301973.png)\n\nCollection接口继承了Iterable接口，Iterable接口中的Iterator( )方法产生（返回） 一个Iterator对象，通过这个对象就可以迭代遍历集合容器中的元素。\n\n```java\nList<Integer> list = new ArrayList<>();\nlist.add(1);\nlist.add(2);\n// 1. 使用迭代器迭代\nIterator<Integer> it = list.iterator();\nwhile(it.hasNext()){\n  \tint i = it.next();\n}\n\n// 2.使用forEach迭代\nfor(int i: list){}\n```\n\n## 适配器模型\n\n例如：java.util.Arrays 的 aslist( )方法可以把数组类型转换成List类型。\n\n```java\n@SafeVarargs\npublic static <T> List<T> asList(T... a)\n```\n\n注意asList方法的参数为泛型的变长参数，不能使用基本类型数组作为参数，要使用对应的封装类型数组\n\n```java\nInteger[] arr = {1,2,3};\nList list = Arrays.asList(arr);\n    \n// 也可以直接按以下方式调用\nList list = Arrays.asList({1,2,3});\n```\n\n","tags":["Java容器"],"categories":["Java","Java容器"]},{"title":"1.复杂度分析","url":"/2019/11/30/1.ComplexityAnalysis/","content":"\n计算机讲求的是运行的更快，更省内存空间，也就是对执行效率（时间）和资源消耗（空间）的要求。故在写算法时，要进行时间复杂度和空间复杂度分析，才能评断算法的好坏。\n\n<!-- more -->\n\n## 为什么要复杂度分析\n\n直接拿算法进行测试，得到执行时间和占用空间大小，这叫*事后统计法*\n1. 测试结果受测试环境影响\n2. 测试结果受数据规模影响\n \n我们需要用一个不用具体数据进行测试，就能估计出算法的执行时间和占用空间的方法， 即进行时间、空间复杂度分析。\n\n## 复杂度分析的方法（大O复杂度表示法）\n### 时间复杂度分析\n> 时间复杂度（Time complexity）：代码执行时间随数据规模增长的变化趋势\n\n1. 关注循环执行次数最多的一段代码\n2. 加法法则： 总时间复杂度 = 量级最大的那段代码的复杂度\n    > 给定已知的循环次数，即使是10000次，十万次，也是常量级时复\n\n    ```\n    int cal(int n) { \n        int sum_1 = 0; \n        int p = 1; \n        for (; p < 1000; ++p) { \n            sum_1 = sum_1 + p; \n        } \n        \n        int sum_2 = 0; \n        int q = 1; \n        for (; q < n; ++q) { \n            sum_2 = sum_2 + q; \n        } \n        \n        int sum_3 = 0; \n        int i = 1; \n        int j = 1; \n        for (; i <= n; ++i) { \n            j = 1; \n            for (; j <= n; ++j) { \n                sum_3 = sum_3 + i * j; \n            } \n        } \n        \n        return sum_1 + sum_2 + sum_3; }\n    ```\n\n    > 第一段代码循环大概1000次，也是常量级，时复O（1）; 第二段循环n次，时复O（n）； 第三段循环n^2次，时复O（n^2）。 所以整个函数的时复为O（n^2）\n\n3. 乘法法则：嵌套代码复杂度 = 嵌套代码内外循环复杂度的乘积\n\n### 常见时间复杂度实例分析\n![Alt](img/ordinaryComplexity.jpg)\n1. 将对数阶O（logn）循环n次， 就是O（nlogn）\n2. O（m + n）， O（m * n） 数据规模m、n均未知\n\n### 空间复杂度分析\n空间复杂度（Space complexity）：算法的存储空间随数据规模增长的变化趋势\n常见空间复杂度： O（1） O（n） O（n^2）\n\n## 最好最坏时间复杂度\n## 平均时间复杂度\n\nfind（）：假设查找x在数组中的位置，存在0 ~ n-1位置上和不在数组中，共n+1中情况，那么平均情况的复杂度=（1+2+...+n+n）/（n+1）= n（n+3）/ 2(n+1)， 去除系数、低阶、常量，时复为O（n）\n\n以上计算方法是错误的，没有考虑每种情况的概率。x是否存在于数组的概率各占1/2， x存在于0 ~ n-1位置上的概率各为1/2n, 所以（1+2+...+n）* 1/2n + n * 1/2 = 3n + 1 / 4, 故平均时复为O（n）。加入概率的叫做加权平均值（期望值），故称为加权平均时间复杂度,简称平均时间复杂度。\n\n## 均摊时间复杂度\n\n```\n // array表示一个长度为n的数组\n // 代码中的array.length就等于n\n int[] array = new int[n];\n int count = 0;\n \n void insert(int val) {\n    if (count == array.length) {\n       int sum = 0;\n       for (int i = 0; i < array.length; ++i) {\n          sum = sum + array[i];\n       }\n       array[0] = sum;\n       count = 1;\n    }\n\n    array[count] = val;\n    ++count;\n }\n```\n> 这段代码的功能是：数组没满时，直接插入元素；数组已满时，计算所有元素的和，清空数组，并将和存放在array[0],继续插入元素。\n> 1. 最好时复：数组没满，直接插入，O（1）\n> 2. 最坏时复：数组已满，先求和再插入语， O（n）\n> 3. 平均时复：根据插入的位置不同，分为0 ~ n-1， 和数组已满插入元素，共n+1种情况，每种情况发生的概率是1 / n+1。 而前n种的时复是O（1）， 最后一种的时复是O（n）， 所以1 * 1/n+1 + ... + 1 * 1/n+1 + n * 1/n+1 = 2n / n+1, 故平均时复为O（1）\n> 4. 什么时候使用平均时复或是均摊时复？\n>      \n>    find（）和insert（）的对比：find（）最好情况为O（1），insert（）在大部分情况下为O（1），极端情况才为O（n）。 inset（）的时复出现是有规律的， 一次O（n）插入操作后会有n-1次的O（1）插入操作，针对这种特殊场景，不再使用较复杂的平均时复分析法， 而是采用摊还分析，求均摊时间复杂度。\n> 5. 均摊时复：将耗时最多的一次O（n）操作，均摊到n-1次耗时少的O（1）操作，那么每次操作的时复都是O（1）。故均摊时复为O（1）。\n \n### 什么时候用摊还分析法来估计算法的均摊时间复杂度？\n\n当在特殊场景下，算法操作的时复有规律地分布着，看看是否能够把较高时间复杂度的操作均摊到较低时复的操作上。一般情况，均摊时复等于最好时复。 均摊时复是一种特殊的平均时复。\n\n## 思考题\n\n```\n\n// 全局变量，大小为10的数组array，长度len，下标i。\nint array[] = new int[10]; \nint len = 10;\nint i = 0;\n\n// 往数组中添加一个元素\nvoid add(int element) {\n   if (i >= len) { // 数组空间不够了\n     // 重新申请一个2倍大小的数组空间\n     int new_array[] = new int[len*2];\n     // 把原来array数组中的数据依次copy到new_array\n     for (int j = 0; j < len; ++j) {\n       new_array[j] = array[j];\n     }\n     // new_array复制给array，array现在大小就是2倍len了\n     array = new_array;\n     len = 2 * len;\n   }\n   // 将element放到下标为i的位置，下标i加一\n   array[i] = element;\n   ++i;\n}\n```\n> 最好时复：数组未满，直接添加，O（1）\n> \n> 最坏时复：数组已满，扩容搬移数据后再添加，O（n）\n> \n> 摊还时复： 将搬移数据的操作均摊到前n-1次直接添加的操作，时复等于直接添加的时复O（1）\n> ","tags":["数据结构与算法之美"]},{"title":"Hello World","url":"/2019/11/12/hello-world/","content":"Welcome to [Hexo](https://hexo.io/)! This is your very first post. Check [documentation](https://hexo.io/docs/) for more info. If you get any problems when using Hexo, you can find the answer in [troubleshooting](https://hexo.io/docs/troubleshooting.html) or you can ask me on [GitHub](https://github.com/hexojs/hexo/issues).\n<!-- more -->\n\n## Quick Start\n\n### Create a new post\n\n``` bash\n$ hexo new \"My New Post\"\n```\n\nMore info: [Writing](https://hexo.io/docs/writing.html)\n\n### Run server\n\n``` bash\n$ hexo server\n```\n\nMore info: [Server](https://hexo.io/docs/server.html)\n\n### Generate static files\n\n``` bash\n$ hexo generate\n```\n\nMore info: [Generating](https://hexo.io/docs/generating.html)\n\n### Deploy to remote sites\n\n``` bash\n$ hexo deploy\n```\n\nMore info: [Deployment](https://hexo.io/docs/one-command-deployment.html)\n"}]